<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="这是Sipser的《计算理论导引》的简要笔记. 计算理论还是比较难的...... 前面文法看得相对多一点,后面就疯狂跳了. 第0章 计算理论主要包括三个部分,自动机理论,可计算性理论和复杂性理论. 字母表(alphabet)是一个非空有限集,其中的成员称为字母表的符号.字母表上的字符串(string)是字母表中元素的有限序列,元素的个数称为字符串的长度(记为\(|w|\)),长度为零的字符串称为空">
<meta property="og:type" content="article">
<meta property="og:title" content="计算理论导引笔记">
<meta property="og:url" content="http://example.com/2019/07/09/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%AF%BC%E5%BC%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="PerodicLaw的个人博客">
<meta property="og:description" content="这是Sipser的《计算理论导引》的简要笔记. 计算理论还是比较难的...... 前面文法看得相对多一点,后面就疯狂跳了. 第0章 计算理论主要包括三个部分,自动机理论,可计算性理论和复杂性理论. 字母表(alphabet)是一个非空有限集,其中的成员称为字母表的符号.字母表上的字符串(string)是字母表中元素的有限序列,元素的个数称为字符串的长度(记为\(|w|\)),长度为零的字符串称为空">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-07-09T00:00:00.000Z">
<meta property="article:modified_time" content="2021-03-21T09:04:11.055Z">
<meta property="article:author" content="PeriodicLaw">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2019/07/09/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%AF%BC%E5%BC%95%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算理论导引笔记 | PerodicLaw的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">PerodicLaw的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/07/09/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%AF%BC%E5%BC%95%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PeriodicLaw">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PerodicLaw的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算理论导引笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-09T00:00:00+00:00">2019-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-21 09:04:11" itemprop="dateModified" datetime="2021-03-21T09:04:11+00:00">2021-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这是Sipser的<a target="_blank" rel="noopener" href="https://book.douban.com/subject/30384859/">《计算理论导引》</a>的简要笔记. 计算理论还是比较难的......</p>
<p>前面文法看得相对多一点,后面就疯狂跳了.</p>
<h1 id="第0章">第0章</h1>
<p>计算理论主要包括三个部分,自动机理论,可计算性理论和复杂性理论.</p>
<p>字母表(alphabet)是一个非空有限集,其中的成员称为字母表的符号.字母表上的字符串(string)是字母表中元素的有限序列,元素的个数称为字符串的长度(记为<span class="math inline">\(|w|\)</span>),长度为零的字符串称为空串(记为<span class="math inline">\(\epsilon\)</span>). 字符串有子串,前缀,拼接的概念. 字符串的集合被称为语言(language).</p>
<h1 id="第1章-正则语言">第1章 正则语言</h1>
<h2 id="有限自动机">有限自动机</h2>
<p>(确定性)有限自动机(DFA)是一个五元组<span class="math inline">\(M=(Q,\Sigma,\delta,q_0,F)\)</span>,其中<span class="math inline">\(Q\)</span>为状态的有限集,<span class="math inline">\(\Sigma\)</span>为字母表,<span class="math inline">\(δ:Q\times\Sigma\to Q\)</span>为转移函数,<span class="math inline">\(q_0\in Q\)</span>为初始状态,<span class="math inline">\(F\subseteq Q\)</span>为接受状态集合.DFA可以用状态图表示.</p>
<p>设<span class="math inline">\(w=w_1w_2\cdots w_n\)</span>是一个字符串,如果存在一系列状态<span class="math inline">\(r_0,r_1,\cdots,r_n\)</span>使得<span class="math inline">\(r_0=q_0\)</span>,<span class="math inline">\(\delta(r_i,w_{i+1})=r_{i+1}\)</span>,<span class="math inline">\(r_n\in F\)</span>,则称<span class="math inline">\(w\)</span>被DFA<span class="math inline">\(M\)</span>所接受.DFA<span class="math inline">\(M\)</span>所接受的全体字符串<span class="math inline">\(L(M)=\\{w\mid M接受w\\}\)</span>称为<span class="math inline">\(M\)</span>所接受的语言.特别的,被某个DFA接受的语言称为正规语言(regular language).</p>
<p>对语言我们可以定义正则运算:并运算<span class="math inline">\(A\cup B\)</span>,连接运算<span class="math inline">\(A\circ B\)</span>,星运算(闭包运算)<span class="math inline">\(A^*\)</span>.通过构造DFA乘积的方式我们可以证明正则语言的并还是正则语言.</p>
<h2 id="非确定性">非确定性</h2>
<p>非确定性有限自动机(NFA)是一个五元组<span class="math inline">\(N=(Q,\Sigma,\delta,q_0,F)\)</span>,其中<span class="math inline">\(Q\)</span>为状态的有限集,<span class="math inline">\(\Sigma\)</span>为字母表,<span class="math inline">\(δ:Q\times(\Sigma\cup\epsilon)\to\mathcal{P}(Q)\)</span>为转移函数,<span class="math inline">\(q_0\in Q\)</span>为初始状态,<span class="math inline">\(F\subseteq Q\)</span>为接受状态集合. NFA也可以用状态图表示;它与DFA的主要区别在于可以同时处在多个状态,并且可以进行空串<span class="math inline">\(\epsilon\)</span>的转移.</p>
<p>设<span class="math inline">\(w=w_1w_2\cdots w_n\)</span>是一个字符串,如果在其中插入一些<span class="math inline">\(\epsilon\)</span>得到<span class="math inline">\(w=v_1v_2\cdots v_m\)</span>,并且存在一系列状态<span class="math inline">\(r_0,r_1,\cdots,r_m\)</span>使得<span class="math inline">\(r_0=q_0\)</span>,<span class="math inline">\(r_{i+1}\in\delta(r_i,v_{i+1})\)</span>,<span class="math inline">\(r_m\in F\)</span>,则称<span class="math inline">\(w\)</span>被NFA<span class="math inline">\(N\)</span>所接受.NFA<span class="math inline">\(N\)</span>所接受的全体字符串<span class="math inline">\(L(M)=\\{w\mid N接受w\\}\)</span>称为<span class="math inline">\(N\)</span>所接受的语言.</p>
<p>NFA与DFA是相互等价的.要证明这一点,只需要证明任意NFA都有等价的DFA(即能够接受相同的语言).首先对任意的NFA,改变其转移函数为<span class="math inline">\(\delta&#39;(r,a)=\\{(r&#39;,a)\mid 从\delta(r,a)出发经过若干次\epsilon转移可以到达r&#39;\\}\)</span>,这样就消去了NFA中所有的<span class="math inline">\(\epsilon\)</span>转移. 其次对没有<span class="math inline">\(\epsilon\)</span>转移的NFA,以其状态集<span class="math inline">\(Q\)</span>的子集<span class="math inline">\(\mathcal{P}(Q)\)</span>为新的状态集,子集<span class="math inline">\(R\subseteq\mathcal{P}(Q)\)</span>的状态转移为<span class="math inline">\(\delta&#39;&#39; (R,a)=\cup_{r\in R}{\delta&#39;(r,a)}\)</span>,从而构造出一个DFA.可以看出NFA与这个DFA是等价的.</p>
<p>通过"并联"和"串联"两个NFA,可以证明正则语言的并和连接依然是正则语言;通过连接接受状态到初始状态构造NFA,可以证明正则语言的星运算依然是正则语言.</p>
<h2 id="正则表达式">正则表达式</h2>
<p>从字母,<span class="math inline">\(\epsilon\)</span>,<span class="math inline">\(\emptyset\)</span>出发经过有限次正则运算得到的表达式称为正则表达式.</p>
<p>正则表达式与DFA等价(也与正则语言等价).这是因为,一方面可以构造接受字母,<span class="math inline">\(\epsilon\)</span>,<span class="math inline">\(\emptyset\)</span>的NFA,再由正则运算的封闭性可知,任意正则表达式可由NFA接受,亦可由DFA接受;另一方面,设有一个DFA,把转移的字母变为正则表达式得到一个推广的自动机GNFA,对GNFA的状态个数归纳可以构造出DFA接受的正则表达式.(这部分过程比较复杂;此外另一个方向也有一种直接的证明,通过归纳构造从状态i到j且经过的状态编号不超过k的所有字符串对应的正则表达式,可见Hopcroft的书)</p>
<h2 id="非正则语言">非正则语言</h2>
<p>对于正则语言,有如下的泵引理:对任一正则语言<span class="math inline">\(A\)</span>,存在一个整数<span class="math inline">\(p\)</span>使得对任何<span class="math inline">\(A\)</span>中的字符串<span class="math inline">\(\mid s\mid\ge p\)</span>,<span class="math inline">\(s\)</span>可以被分为<span class="math inline">\(s=xyz\)</span>使得:1.对任何非负整数<span class="math inline">\(i\)</span>,<span class="math inline">\(xy^iz\)</span>属于<span class="math inline">\(A\)</span>; 2.<span class="math inline">\(\mid y\mid &gt;0\)</span>; 3.<span class="math inline">\(\mid xy\mid\le p\)</span>.</p>
<p>这个引理成立的原因在于,若<span class="math inline">\(A\)</span>对应的DFA有<span class="math inline">\(p\)</span>个状态,那么对于长度大于等于<span class="math inline">\(p\)</span>的字符串<span class="math inline">\(s\)</span>,它必然经过<span class="math inline">\(p+1\)</span>个状态,由抽屉原理必然经过两个相同的状态;根据这两个相同的状态将<span class="math inline">\(s\)</span>分为三个部分,几个性质即可得证.</p>
<p>泵引理主要用于证明一些语言不是正则语言.</p>
<h1 id="第2章-上下文无关语言">第2章 上下文无关语言</h1>
<h2 id="上下文无关文法">上下文无关文法</h2>
<p>上下文无关文法(CFG)是一个四元组<span class="math inline">\(G=(V,\Sigma,R,S)\)</span>,其中<span class="math inline">\(V\)</span>为变量集,<span class="math inline">\(\Sigma\)</span>为(终结)符号集,<span class="math inline">\(R\)</span>为规则集合(每条规则包括一个变量和一个由变量和符号组成的字符串,即<span class="math inline">\(R\subseteq V\times (V\cup\Sigma)^*\)</span>,一般写成<span class="math inline">\(A\to w\)</span>的形式),<span class="math inline">\(S\in V\)</span>为初始变量. 如果有多个规则从同一个变量<span class="math inline">\(A\)</span>导出多个字符串<span class="math inline">\(w_1,\cdots,w_n\)</span>,那么通常简写为<span class="math inline">\(A\to w_1|\cdots|w_n\)</span>.</p>
<p>对于两个由变量和符号组成的字符串<span class="math inline">\(u,v\)</span>,如果<span class="math inline">\(A\to w\)</span>是一条规则,将<span class="math inline">\(u\)</span>中的某一个<span class="math inline">\(A\)</span>替换为<span class="math inline">\(w\)</span>即得到字符串<span class="math inline">\(v\)</span>,那么称<span class="math inline">\(u\)</span>派生<span class="math inline">\(v\)</span>,记作<span class="math inline">\(u\implies v\)</span>. 由初始变量派生的仅含符号的字符串全体称为CFG<span class="math inline">\(G\)</span>派生的语言,由某个CFG派生的语言称为上下文无关语言(CFL).</p>
<p>任何正则语言都是CFL.这是因为正则语言对应DFA,将DFA的每个状态对应一个变量,根据转移函数和起始/接受状态就能得到一个CFG.</p>
<p>如果在派生某个字符串<span class="math inline">\(w\)</span>的过程中,总是替换最左边的变量,则称这样的派生是最左派生;具有两个不同的最左派生的字符串被称作被有歧义地派生(derived ambiguously).存在某个有歧义地派生的字符串的CFG被称为有歧义的文法.仅能由有歧义的CFG派生的CFL被称为内在歧义的语言.这样的语言是存在的.</p>
<p>如果CFG<span class="math inline">\(G\)</span>的每条规则形如<span class="math inline">\(A\to BC\)</span>(<span class="math inline">\(B\)</span>,<span class="math inline">\(C\)</span>均为非初始的变量)或者<span class="math inline">\(A\to a\)</span>(a为某个符号),那么这样的CFG被称为Chomsky标准文法.任何一个CFL均可由某个Chomsky标准文法派生.这是因为,首先添加一个新的初始变量使得后续不会出现初始变量;接着通过添加规则的方式可以消去所有派生出<span class="math inline">\(\epsilon\)</span>的规则;然后通过替换的方式可以消去所有只派生一个变量的规则;最后对于剩下的规则,通过两两合并的方式可以转换为标准文法的规则(变量对应第一种规则,符号先变成变量再对应第二种规则).</p>
<h2 id="下推自动机">下推自动机</h2>
<p>下推自动机(PDA)是一个六元组<span class="math inline">\(M=(Q,\Sigma,\Gamma,\delta,q_0,F)\)</span>,其中<span class="math inline">\(Q\)</span>为状态集合,<span class="math inline">\(\Sigma\)</span>为输入符号集合,<span class="math inline">\(\Gamma\)</span>为栈符号集合,<span class="math inline">\(\delta:Q\times(\Sigma\cup\epsilon)\times(\Gamma\cup\epsilon)\to\mathcal{P}(Q\times(\Gamma\cup\epsilon))\)</span>为转移函数,<span class="math inline">\(q_0\in Q\)</span>为初始状态,<span class="math inline">\(F\subseteq Q\)</span>为接受状态集合.</p>
<p>设<span class="math inline">\(w=w_1w_2\cdots w_n,w_i\in(\Sigma\cup\epsilon)\)</span>是输入序列,如果存在一系列状态<span class="math inline">\(r_0,r_1,\cdots,r_n\in Q\)</span>和栈序列<span class="math inline">\(s_0,s_1,...,s_n\in\Gamma^*\)</span>,使得<span class="math inline">\(r_0=q_0,s_0=\epsilon\)</span>,<span class="math inline">\((r_{i+1},b)\in\delta(r_i,w_{i+1},a)\)</span>其中<span class="math inline">\(s_i=at,s_{i+1}=bt\)</span>,并且<span class="math inline">\(r_n\in F\)</span>,则称<span class="math inline">\(w\)</span>被PDA<span class="math inline">\(M\)</span>接受.<span class="math inline">\(M\)</span>所接受的所有字符串构成<span class="math inline">\(M\)</span>所接受的语言.</p>
<p>可以看到PDA和NFA的不同主要在于PDA具有一个栈,以及出栈入栈的能力. 此外,PDA本身的机制并不能给栈初始化,转移时多个字符入栈,判断栈空或是判断输入结束;但是通过适当添加符号和状态,即可实现这些功能.</p>
<p>PDA与CFG等价.这是因为,一方面对于任一CFG派生出的CFL,我们构造状态使得:如果输入和栈顶都为某个符号,则该符号可以出栈;如果输入为<span class="math inline">\(\epsilon\)</span>而栈顶为某个变量,则可以按照CFG的规则将该变量出栈,由规则派生的字符串入栈.当栈空时即接受输入.这样构造出的PDA可以接受该语言. 另一方面,对于任意PDA,不妨设它只有一个接受状态,接受前栈为空,且每次转移要么只出栈要么只入栈.以输入符号为文法的符号,且对于每对状态<span class="math inline">\((p,q)\)</span>构造变量<span class="math inline">\(A_{pq}\)</span>.建立三种规则:如果从状态<span class="math inline">\(p\)</span>输入<span class="math inline">\(a\)</span>并入栈<span class="math inline">\(u\)</span>可以转移至<span class="math inline">\(r\)</span>,并且从状态<span class="math inline">\(s\)</span>输入<span class="math inline">\(b\)</span>并出栈<span class="math inline">\(u\)</span>可以转移至<span class="math inline">\(q\)</span>,那么建立规则<span class="math inline">\(A_{pq}\to aA_{rs}b\)</span>;对于任意状态<span class="math inline">\(p,q,r\)</span>,建立规则<span class="math inline">\(A_{pq}\to A_{pr}A_{rq}\)</span>;最后建立规则<span class="math inline">\(A_{pp}\to\epsilon\)</span>.可以证明,这样构造的<span class="math inline">\(A_{pq}\)</span>生成的字符串对应所有从状态<span class="math inline">\(p\)</span>和空栈出发能够转移至状态<span class="math inline">\(q\)</span>和空栈的输入符号串.这样,以初始状态和接受状态构造的变量<span class="math inline">\(A_{q_0q}\)</span>为初始变量即得等价的CFG.</p>
<h2 id="非上下文无关语言">非上下文无关语言</h2>
<p>CFL也有泵引理,其内容为:设<span class="math inline">\(A\)</span>为CFL,则存在一个正整数<span class="math inline">\(p\)</span>使得,只要<span class="math inline">\(A\)</span>中的字符串<span class="math inline">\(s\)</span>满足<span class="math inline">\(\mid s\mid\ge p\)</span>,那么可以将其分为五部分<span class="math inline">\(s=uvxyz\)</span>,使得:1.对任意非负整数<span class="math inline">\(i\)</span>,<span class="math inline">\(uv^ixy^iz\)</span>属于<span class="math inline">\(A\)</span>;2.<span class="math inline">\(\mid vy\mid &gt;0\)</span>;3.<span class="math inline">\(\mid vxy\mid\le p\)</span>.</p>
<p>要证明它,只需要注意<span class="math inline">\(A\)</span>的CFG中变量的个数有限.当<span class="math inline">\(s\)</span>的长度充分长时,考虑从起始变量出发得到<span class="math inline">\(s\)</span>的解析树,这个树足够深,于是根据抽屉原理,从根到某个叶子上必然经过两个相同的变量.根据这两个重复变量生成的子树,可以将<span class="math inline">\(s\)</span>分成五个部分,再注意到用相同变量生成的子树替换后仍为合法的字符串,三个性质即可得证.</p>
<p>这个引理也可以被用来证明一些语言不是CFL.</p>
<h2 id="确定性上下文无关语言">确定性上下文无关语言</h2>
<p>(这一节的内容比较难,所以我只是粗略的看了一部分)</p>
<p>与(非确定性)下推自动机相比,确定性下推自动机(DPDA)允许了<span class="math inline">\(\epsilon\)</span>转移的存在,但对于每个状态,输入和栈,要求至多转移转移到一个状态(也允许不转移);并且输入为<span class="math inline">\(a\)</span>或<span class="math inline">\(\epsilon\)</span>,栈顶为<span class="math inline">\(x\)</span>或<span class="math inline">\(\epsilon\)</span>时,四种情况必须有一种可以转移.DPDA接受的语言称为确定性上下文无关语言(DCFL). DCFL对补预算封闭,由此可以得到是CFL但不是DCFL的语言存在.</p>
<p>对应也有确定性上下文无关文法(DCFG),主要是在CFG的基础上要求每个字符串倒推回起始变量的过程具有唯一性.具体地说,如果字符串<span class="math inline">\(u\)</span>中的某一字串<span class="math inline">\(h\)</span>可以按照规则<span class="math inline">\(T\to h\)</span>倒推,那么称<span class="math inline">\(h\)</span>是<span class="math inline">\(u\)</span>的一个句柄(handle);如果<span class="math inline">\(h\)</span>是<span class="math inline">\(v=xhy\)</span>的句柄并且对任何<span class="math inline">\(\hat{y}\)</span>,<span class="math inline">\(h\)</span>都是<span class="math inline">\(xh\hat{y}\)</span>中的唯一句柄,则称<span class="math inline">\(h\)</span>是<span class="math inline">\(v\)</span>的强迫句柄(forced handle);如果每个合法字符串都有一个强迫句柄则称该文法为DCFG.判断一个CFG是否为DCFG有一个测试方法叫做DK测试.事实上,DCFG和DPDA是等价的.</p>
<h1 id="第3章-church-turing论题">第3章 Church-Turing论题</h1>
<h2 id="图灵机">图灵机</h2>
<p>图灵机(TM)是一个七元组<span class="math inline">\(M=(Q,\Sigma,\Gamma,\delta,q_0,q_{accept},q_{reject})\)</span>,其中<span class="math inline">\(Q\)</span>是状态集合,<span class="math inline">\(\Sigma\)</span>是输入符号集合(不包含空符号),<span class="math inline">\(\Gamma\)</span>为纸带符号集合(包含空符号和<span class="math inline">\(\Sigma\)</span>),$:QQ\{ L,R \} <span class="math inline">\(为转移函数,\)</span>q_0Q<span class="math inline">\(为初始状态,\)</span>q_{accept}Q<span class="math inline">\(为接受状态,\)</span>q_{reject}Q$为拒绝状态.</p>
<p>图灵机在工作时包括三个要素:状态,纸带内容,纸带头位置,它们合起来叫做图灵机的一个配置(configuration),可以用<span class="math inline">\(u\,q\,v\)</span>表示纸带内容为<span class="math inline">\(uv\)</span>,状态为<span class="math inline">\(q\)</span>且纸带头指向<span class="math inline">\(v\)</span>的第一个字符.配置的转移方式是:如果<span class="math inline">\(\delta(q_i,b)=(q_j,c,L)\)</span>,那么<span class="math inline">\(ua\,q_i\,bv\)</span>可以转移到<span class="math inline">\(u\,q_j\,abv\)</span>;如果<span class="math inline">\(\delta(q_i,b)=(q_j,c,R)\)</span>,那么<span class="math inline">\(ua\,q_i\,bv\)</span>可以转移到<span class="math inline">\(uab\,q_i\,v\)</span>.一个例外是在纸带最左端向左移动,纸带头位置不变.</p>
<p>当输入字符串<span class="math inline">\(w\)</span>时,图灵机以<span class="math inline">\(q_0\,w\)</span>为初始配置.如果经过有限次转移后图灵机进入<span class="math inline">\(q_{accept}\)</span>,则称该图灵机接受(识别)该字符串;该图灵机接受的全体字符串称为该图灵机接受的语言;被某个图灵机接受的语言称为图灵可识别语言(Turing-recognizable,或称递归可枚举语言).如果该图灵机对于任意输入,经过有限次转移后总是进入<span class="math inline">\(q_{accept}\)</span>或是<span class="math inline">\(q_{reject}\)</span>,则称该图灵机是判定机(decider);判定机识别的语言称为被该图灵机所判定的语言;被某个图灵机判定的语言称为图灵可判定语言(Turing-decidable,或称递归语言).</p>
<h2 id="图灵机的变种">图灵机的变种</h2>
<p>给图灵机添加多个纸带即得到多纸带图灵机,它能够在多个纸带上同时修改,并且具有多个纸带头.多纸带图灵机的运算能力与图灵机等价,因为我们可以通过给不同纸带的字符串之间插入分隔符#的方式用单纸带模拟多纸带,并通过在符号上添加点(可以理解为替换成对应符号)表示多个纸带头的位置,当修改到多纸带上的空字符时将对应单纸带上的内容平移.</p>
<p>允许图灵机转移至多个状态即得到非确定性图灵机.非确定性图灵机的运算能力与图灵机等价,因为我们可以将非确定性图灵机的运行看作一棵树,对这棵树做BFS即可模拟非确定性图灵机.</p>
<h2 id="算法的定义">算法的定义</h2>
<p>算法并没有一个严格的定义.Church-Turing论题认为,直观上的算法和图灵机所实现的算法是等价的.</p>
<h1 id="第4章-可判定性">第4章 可判定性</h1>
<h2 id="可判定语言">可判定语言</h2>
<p>语言<span class="math inline">\(A_{DFA}=\\{(B,w)\mid B是某个接受字符串w的DFA\\}\)</span>是可判定的,因为我们可以用图灵机模拟DFA的运行.语言<span class="math inline">\(A_{NFA}=\\{(B,w)\mid B是某个接受字符串w的NFA\\}\)</span>和<span class="math inline">\(A_{REX}=\\{(R,w)\mid R是某个生成字符串w的正则表达式\\}\)</span>也是可判定的,因为我们可以将NFA和正则表达式转化为DFA.</p>
<p>语言<span class="math inline">\(E_{DFA}=\\{A\mid A是一个DFA,且L(A)=\emptyset \\}\)</span>是可判定的,因为我们可以用图灵机对DFA遍历(搜索)其所有可能到达的状态,接受状态是否在其中就决定了这个DFA的语言是否为空.语言<span class="math inline">\(EQ_{DFA}=\\{(A,B)\mid A,B是DFA,且L(A)=L(B)\\}\)</span>是可判定的,因为我们可以构造<span class="math inline">\(L(A),L(B)\)</span>的对称差,因为正则语言对补交并封闭所以对称差是某个DFA的语言<span class="math inline">\(L(C)\)</span>,因而可用<span class="math inline">\(E_{DFA}\)</span>来判定相等.</p>
<p>语言<span class="math inline">\(A_{CFG}=\\{(G,w)\mid G是某个派生字符串w的CFG\\}\)</span>是可判定的,因为我们可以将<span class="math inline">\(G\)</span>转换为Chomsky标准文法,而它派生一个长度为n的字符串恰好要替换2n-1次,所以可以通过搜索判定<span class="math inline">\(A_{CFG}\)</span>.语言<span class="math inline">\(E_{CFG}=\\{G\mid G是某个CFG且L(G)=\emptyset\\}\)</span>是可判定的,因为我们可以从终结字符出发搜索确定每个变量是否能够派生出仅终结字符的字符串,进而判定<span class="math inline">\(G\)</span>是否能派生出仅终结字符的字符串.</p>
<p>此外,任何CFL都是可判定的.这是因为我们可以直接利用<span class="math inline">\(A_{CFG}\)</span>来判定某个字符串是否合法.</p>
<h2 id="不可判定性">不可判定性</h2>
<p>图灵不可识别语言必定存在,因为图灵机全体构成可数集而语言全体构成不可数集.</p>
<p>语言<span class="math inline">\(A_{TM}=\\{(M,w)\mid M是接受字符串w的图灵机\\}\)</span>是图灵不可判定的.这是因为如果它可判定,设判定它的图灵机为<span class="math inline">\(H\)</span>,那么可以构造图灵机<span class="math inline">\(D\)</span>,输入一个图灵机<span class="math inline">\(M\)</span>的编码,如果<span class="math inline">\(M\)</span>接受<span class="math inline">\(M\)</span>的编码那么<span class="math inline">\(D\)</span>拒绝<span class="math inline">\(M\)</span>的编码,反之接受.不论<span class="math inline">\(D\)</span>接受还是拒绝<span class="math inline">\(D\)</span>自身的编码,都会产生矛盾.</p>
<p>一个语言是图灵可判定的当且仅当它和它的补都是图灵可识别的.这是因为一方面如果它是图灵可判定的那它和它的补显然是图灵可识别的;反过来如果它和它的补都是图灵可识别的,那么我们可以构造一个图灵机来并行地判定它和它的补是否可识别,当其中一个停机时即判定成功.因为<span class="math inline">\(A_{TM}\)</span>是图灵可识别的所以它的补是图灵不可识别语言.</p>
<h1 id="第5章-可归约性">第5章 可归约性</h1>
<p>可归约性可以用来证明不可判定性.如果某个问题A与问题B之间具有这样的性质:若找到了B的解决方法,那么A也能解决,那么(不严格地)就称A可以归约到B.可见如果A是不可判定的,那么B也是不可判定的.</p>
<h2 id="语言中的不可判定问题">语言中的不可判定问题</h2>
<h3 id="几个不可判定问题">几个不可判定问题</h3>
<p>停机问题<span class="math inline">\(HALT_{TM}=\\{(M,w)\mid M在输入w下停机\\}\)</span>不可判定.这是因为,如果它可判定,我们可以构造一个图灵机用于判定<span class="math inline">\(A_{TM}\)</span>:先判定是否停机,如果停机再对这个图灵机模拟.这说明<span class="math inline">\(A_{TM}\)</span>可归约到<span class="math inline">\(HALT_{TM}\)</span>,因此<span class="math inline">\(HALT_{TM}\)</span>不可判定.</p>
<p>语言<span class="math inline">\(E_{TM}=\\{M\mid M是一个图灵机且L(M)=\emptyset\\}\)</span>不可判定.这是因为,如果它可判定,对于任一图灵机<span class="math inline">\(M\)</span>和输入<span class="math inline">\(w\)</span>,我们构造图灵机<span class="math inline">\(M_1\)</span>使得:若输入为<span class="math inline">\(w\)</span>则由<span class="math inline">\(M\)</span>处理,否则拒绝,于是判定<span class="math inline">\(L(M_1)\)</span>是否为空就能判定<span class="math inline">\(M\)</span>是否接受<span class="math inline">\(w\)</span>.这说明<span class="math inline">\(A_{TM}\)</span>可归约到<span class="math inline">\(E_{TM}\)</span>,因此<span class="math inline">\(E_{TM}\)</span>不可判定.</p>
<p>语言<span class="math inline">\(REGULAR_{TM}=\\{M\mid M是一个图灵机且L(M)是正则语言\\}\)</span>不可判定.这是因为,如果它可判定,对于任一图灵机<span class="math inline">\(M\)</span>和输入<span class="math inline">\(w\)</span>,我们选取一个非正则语言,并构造图灵机<span class="math inline">\(M_2\)</span>使得:若输入为该非正则语言则接受;否则让<span class="math inline">\(M\)</span>处理<span class="math inline">\(w\)</span>,若<span class="math inline">\(M\)</span>接受<span class="math inline">\(w\)</span>则<span class="math inline">\(M_2\)</span>接受输入,于是判定<span class="math inline">\(L(M_2)\)</span>是否正则就能判定<span class="math inline">\(M\)</span>是否接受<span class="math inline">\(w\)</span>.这说明<span class="math inline">\(A_{TM}\)</span>可归约到<span class="math inline">\(REGULAR_{TM}\)</span>,因此<span class="math inline">\(REGULAR_{TM}\)</span>不可判定.</p>
<p>语言<span class="math inline">\(EQ_{TM}=\\{(M_1,M_2)\mid L(M_1)=L(M_2)\\}\)</span>不可判定.这是因为,如果它可判定,对于任一图灵机<span class="math inline">\(M\)</span>,我们判定它与拒绝所有输入的图灵机是否等价,那么就能判定<span class="math inline">\(L(M)\)</span>是否为空.这说明<span class="math inline">\(EQ_{TM}\)</span>可归约到<span class="math inline">\(E_{TM}\)</span>,因此<span class="math inline">\(E_{TM}\)</span>不可判定.</p>
<h3 id="计算历史方法">计算历史方法</h3>
<p>计算历史就是图灵机在状态转移时构成的配置的序列.线性有界自动机(LBA)是要求纸带头不能超出输入部分的范围的图灵机.</p>
<p>语言<span class="math inline">\(A_{LBA}=\\{(M,w)\mid M是接受输入w的LBA\\}\)</span>是可判定的.这是因为字母个数有限,因而LBA的可能配置个数是有限的,图灵机只需要模拟有限步即可做出判定.</p>
<p>语言<span class="math inline">\(E_{LBA}=\\{M\mid M是一个LBA且L(M)=\emptyset\\}\)</span>不可判定.这是因为,如果它可判定,对于任一图灵机<span class="math inline">\(M\)</span>和输入<span class="math inline">\(w\)</span>,构造一个LBA<span class="math inline">\(B\)</span>,它接受输入<span class="math inline">\(x\)</span>当且仅当<span class="math inline">\(x\)</span>是<span class="math inline">\(M\)</span>接受<span class="math inline">\(w\)</span>的一个计算历史.由于只需要检查起始和结束的配置以及相邻的配置是否符合要求,所以纸带头不需要超出输入部分.判断<span class="math inline">\(B\)</span>是否为空即可判定<span class="math inline">\(M\)</span>是否接受<span class="math inline">\(w\)</span>.这说明<span class="math inline">\(A_{TM}\)</span>可归约到<span class="math inline">\(E_{LBA}\)</span>,因此<span class="math inline">\(E_{LBA}\)</span>不可判定.</p>
<p>语言<span class="math inline">\(ALL_{CFG}=\\{G\mid G是一个CFG且L(G)为全集\\}\)</span>不可判定.这是因为,如果它可判定,对于任一图灵机<span class="math inline">\(M\)</span>和输入<span class="math inline">\(w\)</span>,构造一个PDA<span class="math inline">\(D\)</span>,它输入<span class="math inline">\(M\)</span>的一个计算历史,如果三种情况之一发生就拒绝输入(要用非确定性并行地检测):1.第一个配置不是输入<span class="math inline">\(w\)</span>的配置;2.最后一个配置不是处于接收状态;3.其中某个转移不是合法的转移.此外为了便于检查第三种情况,需要调整输入的顺序使得相邻的两个配置的方向恰好相反.</p>
<h2 id="一个简单的不可判定问题">一个简单的不可判定问题</h2>
<p>波斯特对应问题(PCP)是指给定一组两两配对的字符串,判定能否(可重复地)选出一些配对排列起来,使得被配对的双方分别拼成两个相同的字符串.PCP是不可判定的.证明的细节比较繁琐,大概思路是先转化为对第一个配对有要求的MPCP,假设MPCP可判定,对于任一图灵机<span class="math inline">\(M\)</span>和输入<span class="math inline">\(w\)</span>,如果某个配置可以转移到另一个配置就将其配对起来,由MPCP取出这样的配对序列,从而得到一个<span class="math inline">\(M\)</span>接受<span class="math inline">\(w\)</span>的状态序列,于是<span class="math inline">\(A_{TM}\)</span>可归约到PCP.</p>
<h2 id="映射不可规约性">映射不可规约性</h2>
<p>如果存在一个图灵机<span class="math inline">\(M\)</span>,如果输入<span class="math inline">\(w\)</span>,那么<span class="math inline">\(M\)</span>以纸带内容<span class="math inline">\(f(w)\)</span>停机,则称<span class="math inline">\(f\)</span>是可计算函数. 如果存在可计算函数<span class="math inline">\(f\)</span>,使得对任意<span class="math inline">\(w\)</span>,<span class="math inline">\(w\in A\)</span>当且仅当<span class="math inline">\(f(w)\in B\)</span>,则称语言<span class="math inline">\(A\)</span>通过映射可归约到<span class="math inline">\(B\)</span>,记作<span class="math inline">\(A\le_mB\)</span>,<span class="math inline">\(f\)</span>称作<span class="math inline">\(A\)</span>到<span class="math inline">\(B\)</span>的规约.</p>
<p>可归约性有这样的性质:如果<span class="math inline">\(A\le_mB\)</span>,<span class="math inline">\(B\)</span>可判定,则<span class="math inline">\(A\)</span>可判定;如果<span class="math inline">\(A\le_mB\)</span>,<span class="math inline">\(A\)</span>不可判定,则<span class="math inline">\(B\)</span>不可判定.此外,如果<span class="math inline">\(A\le_mB\)</span>,<span class="math inline">\(B\)</span>图灵可识别,则<span class="math inline">\(A\)</span>图灵可识别.由此可以证明<span class="math inline">\(EQ_{TM}\)</span>和它的补都是图灵不可识别的.</p>
<h1 id="第6章-可计算性高级专题">第6章 可计算性高级专题</h1>
<h2 id="递归定理">递归定理</h2>
<p>递归定理说的是，如果<span class="math inline">\(T\)</span>是一个二元计算函数<span class="math inline">\(t\)</span>的图灵机,那么存在一个一元计算函数<span class="math inline">\(r\)</span>的图灵机<span class="math inline">\(R\)</span>,使得对任意的字符串<span class="math inline">\(w\)</span>都有<span class="math inline">\(r(w)=t(R,w)\)</span>.它体现了机器具有自指的能力. 为了证明这个定理,需要构造两个图灵机<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>:<span class="math inline">\(B\)</span>输入一个字符串,构造一个可以输出该字符串的图灵机,将其编码并和输入的字符串连接起来输出.<span class="math inline">\(A\)</span>无输入而输出<span class="math inline">\(BT\)</span>的编码.最后将<span class="math inline">\(ABT\)</span>连接起来作为<span class="math inline">\(R\)</span>,此时的<span class="math inline">\(R\)</span>接受字符串<span class="math inline">\(w\)</span>,<span class="math inline">\(w\)</span>和<span class="math inline">\(B\)</span>的输出<span class="math inline">\(ABT=R\)</span>作为<span class="math inline">\(T\)</span>的输入,<span class="math inline">\(T\)</span>的输出又作为<span class="math inline">\(R\)</span>的输出,这就得到了<span class="math inline">\(r(w)=t(R,w)\)</span>.</p>
<p>递归定理使得我们在构造图灵机时可以直接利用它自身的编码.作为其应用,语言<span class="math inline">\(MIN_{TM}=\\{M\mid M是图灵机,且不存在和M等价的比M描述更短的图灵机\\}\)</span>不可判定;任何可计算一元函数<span class="math inline">\(t\)</span>都有不动点,即存在图灵机<span class="math inline">\(R\)</span>使得<span class="math inline">\(t(R)=R\)</span>.</p>
<h2 id="逻辑理论的可归约性">逻辑理论的可归约性</h2>
<p>若只使用加法,则自然数上所有真命题(这里要求是前束的闭式)的集合<span class="math inline">\(Th(\mathbb{N},+)\)</span>可判定.而若使用加法和乘法,则<span class="math inline">\(Th(\mathbb{N},+,\times)\)</span>不可判定.进一步地我们还能证明Godel不完备性定理.</p>
<p>(这节的证明没怎么看懂,所以顺带后面两节我也跳了)</p>
<h2 id="图灵可归约性">图灵可归约性</h2>
<h2 id="信息的定义">信息的定义</h2>
<h1 id="第7章-时间复杂度">第7章 时间复杂度</h1>
<h2 id="测量复杂度">测量复杂度</h2>
<p>设<span class="math inline">\(M\)</span>为图灵机,则<span class="math inline">\(M\)</span>的时间复杂度是一个函数<span class="math inline">\(f:\mathbb{N}\to\mathbb{N}\)</span>,使得当输入的长度为<span class="math inline">\(n\)</span>时,<span class="math inline">\(M\)</span>的运行步数最多为<span class="math inline">\(f(n)\)</span>.对于时间复杂度,我们可以使用微积分里的大O/小o记号.对于非确定性图灵机,其时间复杂度是每个分支中最多的运行步数.</p>
<p>设<span class="math inline">\(t(n)\ge n\)</span>.任何时间复杂度为<span class="math inline">\(t(n)\)</span>的多纸带图灵机等价于时间复杂度为<span class="math inline">\(O(t^2(n))\)</span>的单纸带图灵机;这是因为多纸带图灵机每执行一步,对应单纸带图灵机至多执行<span class="math inline">\(O(t(n))\)</span>步.并且,任何时间复杂度为<span class="math inline">\(t(n)\)</span>的非确定性图灵机等价于时间复杂度为<span class="math inline">\(2^{O(t^2(n))}\)</span>的确定性图灵机;这是因为非确定性图灵机的分支个数至多为指数增长.</p>
<h2 id="p类问题">P类问题</h2>
<p>P是所有能被(单纸带确定性)图灵机以多项式时间(<span class="math inline">\(O(n^k)\)</span>)判定的语言组成的类.P类问题在多项式等价(即一个图灵机以多项式的时间增长为代价模拟另一个图灵机)下等价;P类问题往往代表现实中计算机可解的问题.</p>
<p>P类问题的例子包括:判定两点之间是否联通的问题<span class="math inline">\(PATH\)</span>,判定两个数是否互素的问题<span class="math inline">\(RELPRIME\)</span>,任一上下文无关语言(将其CFG转换为Chomsky标准文法,然后用动态规划判定).</p>
<h2 id="np类问题">NP类问题</h2>
<p>NP是所有可被多项式时间下验证(即存在一个图灵机<span class="math inline">\(V\)</span>,使得该语言<span class="math inline">\(A=\\{w\mid 存在某个字符串c,使得V接受(w,c)\\}\)</span>,且图灵机<span class="math inline">\(V\)</span>相对于<span class="math inline">\(w\)</span>的时间复杂度为多项式时间)的语言组成的类;同时也是所有可被某个非确定性图灵机在多项式时间下判定的语言组成的类.</p>
<p>NP类问题的例子包括:判定图中是否存在k-完全子图的问题<span class="math inline">\(CLIQUE\)</span>,判定给定若干数中是否可以选出一些数使得其和等于给定的t的问题<span class="math inline">\(SUBSET-SUM\)</span>.</p>
<h2 id="np完全">NP完全</h2>
<h3 id="多项式时间规约np完全">多项式时间规约,NP完全</h3>
<p>如果存在一个图灵机<span class="math inline">\(M\)</span>,使得它输入<span class="math inline">\(w\)</span>时在多项式时间内停机且输出<span class="math inline">\(f(w)\)</span>,那么称<span class="math inline">\(f\)</span>是多项式时间可计算函数. 如果存在一个多项式时间可计算函数<span class="math inline">\(f\)</span>使得对任意<span class="math inline">\(w\)</span>,<span class="math inline">\(w\in A\)</span>当且仅当<span class="math inline">\(f(w)\in B\)</span>,则称语言<span class="math inline">\(A\)</span>多项式时间下可规约到语言<span class="math inline">\(B\)</span>,记作<span class="math inline">\(A\le_PB\)</span>.</p>
<p>如果<span class="math inline">\(A\le_PB\)</span>,并且<span class="math inline">\(B\in P\)</span>,那么<span class="math inline">\(A\in P\)</span>.</p>
<p>一个语言<span class="math inline">\(B\)</span>,如果<span class="math inline">\(B\in NP\)</span>,并且对任意的<span class="math inline">\(A\in NP\)</span>,都有<span class="math inline">\(A\le_PB\)</span>,那么就称<span class="math inline">\(B\)</span>是NP完全(NPC)的.NP语言具有这样的性质:如果<span class="math inline">\(B\)</span>是NP完全的,且<span class="math inline">\(B\le_PC\)</span>,那么<span class="math inline">\(C\)</span>也是NP完全的.</p>
<p>去掉<span class="math inline">\(B\in NP\)</span>的条件,就称<span class="math inline">\(B\)</span>是NP难的.</p>
<h3 id="cook-levin定理">Cook-Levin定理</h3>
<p>判定某个命题逻辑的公式能否在某个个体变元指派下为真(即判定该公式是否可满足)的问题叫做可满足性问题,记作<span class="math inline">\(SAT\)</span>.Cook-Levin定理说的是<span class="math inline">\(SAT\in NPC\)</span>. 证明的思路在于,首先<span class="math inline">\(SAT\in NP\)</span>显然;其次若<span class="math inline">\(A\in NP\)</span>,把<span class="math inline">\(A\)</span>输入<span class="math inline">\(w\)</span>后从起始到接受的那个分支的配置排成一列得到一个表格,然后根据表格上某个位置是否为某个字符得出若干个体变元,根据转移合法性的要求列出一个可满足的公式.这个公式生成的时间是多项式的,所以<span class="math inline">\(A\le_PSAT\)</span>.</p>
<p>此外,如果要判定的公式是一个每一析取项仅由三个变元组成的合取范式,那么就得到<span class="math inline">\(3SAT\)</span>问题.<span class="math inline">\(3SAT\in NPC\)</span>,因为对于任意<span class="math inline">\(SAT\)</span>中的公式,我们总可以先转化为合取范式,并且对于多于三个变元的析取项,我们总是可以利用<span class="math inline">\(a_1\vee a_2\vee a_3\vee a_4=(a_1\vee a_2\vee z)\wedge(a_3\vee a_4\vee\bar{z})\)</span>来转化成三个变元的.因此<span class="math inline">\(SAT\le_P3SAT\)</span>.</p>
<h3 id="其他的np完全问题">其他的NP完全问题</h3>
<p><span class="math inline">\(CLIQUE\in NPC\)</span>.这是因为给定一个<span class="math inline">\(3SAT\)</span>中的公式,我们以每个析取项的三个变量为顶点,将不同项之间没有互斥关系(即<span class="math inline">\(x\)</span>和<span class="math inline">\(\bar{x}\)</span>不能连接)的顶点连接起来,则判定此图有没有k-完全子图(这里k是析取项的个数)即可判定此公式是否可满足.</p>
<p>判定图中是否存在覆盖所有边的顶点集的问题叫做顶覆盖问题,记作<span class="math inline">\(VERTEX-COVER\)</span>.<span class="math inline">\(VERTEX-COVER\in NPC\)</span>.这是因为给定一个<span class="math inline">\(3SAT\)</span>中的公式,将公式中的每个析取项作为三个相邻顶点,再为每个变量<span class="math inline">\(x\)</span>建立两个相邻顶点<span class="math inline">\(x\)</span>,<span class="math inline">\(\bar{x}\)</span>,最后将这些顶点与相同的析取项中的顶点连接.判定此图有没有顶覆盖即可判定此公式是否可满足.</p>
<p>判定有向图中两顶之间是否存在Hamilton圈的问题记作<span class="math inline">\(HAMPATH\)</span>.<span class="math inline">\(HAMPATH\in NPC\)</span>.同样的,无向图版本的<span class="math inline">\(UHAMPATH\in NPC\)</span>.此外<span class="math inline">\(SUBSET-SUM\in NPC\)</span>.(这些的证明我跳过了)</p>
<h1 id="第8章-空间复杂度">第8章 空间复杂度</h1>
<p>设<span class="math inline">\(M\)</span>为图灵机,则<span class="math inline">\(M\)</span>的时间复杂度是一个函数<span class="math inline">\(f:\mathbb{N}\to\mathbb{N}\)</span>,使得当输入的长度为<span class="math inline">\(n\)</span>时,<span class="math inline">\(M\)</span>使用的纸带单元个数最多为<span class="math inline">\(f(n)\)</span>.对于非确定性图灵机,用某个分支上最多使用个数定义.</p>
<h2 id="savitch定理">Savitch定理</h2>
<p>Savitch定理说的是,设<span class="math inline">\(f(n)\ge n\)</span>,如果一个非确定性图灵机的空间复杂度为<span class="math inline">\(f(n)\)</span>,那么它等价于某个空间复杂度至多为<span class="math inline">\(O(f^2(n))\)</span>的确定性图灵机.这是因为从一个非确定性图灵机出发,我们可以采取二分递归搜索的方式确定从起始到结束是否能在至多<span class="math inline">\(2^{df(n)}\)</span>步内转移;因为搜索是递归的,所以可以重复利用同层的空间.</p>
<h2 id="pspace类">PSPACE类</h2>
<p>PSPACE类由所有具有多项式空间复杂度的语言组成.NPSPACE对应非确定性的情形;根据Savitch定理,<span class="math inline">\(PSPACE=NPSPACE\)</span>.</p>
<h2 id="pspace完备">PSPACE完备</h2>
<p>如果一个语言<span class="math inline">\(B\)</span>满足:1.<span class="math inline">\(B\in PSPACE\)</span>;2.对任何语言<span class="math inline">\(A\in PSPACE\)</span>,<span class="math inline">\(A\)</span>多项式时间可归约到<span class="math inline">\(B\)</span>.则称<span class="math inline">\(B\)</span>是PSPACE完备的.</p>
<p>PSPACE完备的例子包括:判断一个前束闭式是否为真的问题TQBF,判断在给前束闭式中的变量赋值的游戏中是否存在必胜策略的问题FORMULA-GAME,推广的地理游戏(两个人轮流沿着图走,第一个走到重复顶点的人输)是否存在必胜策略的问题GG,</p>
<h2 id="l和nl类">L和NL类</h2>
<h2 id="nl完备">NL完备</h2>
<h2 id="nlconl">NL=coNL</h2>
<h1 id="第9章-难解性">第9章 难解性</h1>
<h2 id="层次定理">层次定理</h2>
<p>设<span class="math inline">\(f(n)\)</span>至少为<span class="math inline">\(O(n\log n)\)</span>.如果存在一个图灵机,输入<span class="math inline">\(n\)</span>个1能够输出<span class="math inline">\(f(n)\)</span>的二进制,且空间复杂度为<span class="math inline">\(O(f(n))\)</span>,则称<span class="math inline">\(f(n)\)</span>空间可构造.将空间换成时间就得到时间可构造.</p>
<p>空间层次定理说的是对任何空间可构造的<span class="math inline">\(f\)</span>,存在某个语言<span class="math inline">\(A\)</span>,它能在<span class="math inline">\(O(f(n))\)</span>的空间复杂度下被判定,却不能在<span class="math inline">\(o(f(n))\)</span>的空间复杂度下被判定.大致思路是构造一个图灵机<span class="math inline">\(D\)</span>,它接受一个图灵机的编码,并限制在<span class="math inline">\(O(f(n))\)</span>的空间复杂度下模拟它,<span class="math inline">\(D\)</span>所识别的语言即为所求;但实际上还需要做一些技术上的改正.</p>
<p>时间层次定理说的是对任何时间可构造的<span class="math inline">\(t\)</span>,存在某个语言<span class="math inline">\(A\)</span>,它能在<span class="math inline">\(O(t(n))\)</span>的时间复杂度下被判定,却不能在<span class="math inline">\(o(\frac{t(n)}{\log t(n)})\)</span>的时间复杂度下被判定.</p>
<p>两个层次定理表明,随着时间/空间复杂度的增长,所能识别的语言是会不断扩大的.</p>
<p>作为层次定理的应用,可以证明<span class="math inline">\(EQ_{REX\uparrow}=\\{(Q,R)\mid Q,R是等价的扩展正则表达式\\}\)</span>(这里扩展正则表达式是指加入了指数运算的正则表达式)是EXPSPACE完备的,因而在时间和空间上都不可能以多项式时间判定.</p>
<h2 id="相对化">相对化</h2>
<p>一个谕示是一个能够直接判定某个字符串是否属于某个语言<span class="math inline">\(A\)</span>的黑箱;带有谕示的黑箱的图灵机叫做谕示图灵机,记作<span class="math inline">\(M^A\)</span>.</p>
<p>我们可以证明存在一个谕示<span class="math inline">\(A\)</span>使得<span class="math inline">\(P^A\neq NP^A\)</span>,又存在一个谕示<span class="math inline">\(B\)</span>使得<span class="math inline">\(P^B=NP^B\)</span>.</p>
<h2 id="电路复杂性">电路复杂性</h2>
<h1 id="第10章-计算复杂度理论高级专题">第10章 计算复杂度理论高级专题</h1>
<h2 id="近似算法">近似算法</h2>
<p>对于有些问题,求出最优解的算法是NP难的,此时也可以转而寻求不是最优的近似算法.如果某个算法的结果至少是最优算法的k倍(越低越优)或k分之一(越高越优),那么称该算法是k-最优的.</p>
<p>例如,对于求最小顶覆盖的问题MIN-VERTEX-COVER,如果随意找一条未被覆盖的边并标记它的某个顶点,不断进行下去,就得到一个多项式时间的2-最优算法.又例如求最大割的问题MAX-CUT,如果不断找出移动后能使割的容量增大的顶点就调整该顶点,直到无法调整(贪心),就得到一个多项式时间的2-最优算法.</p>
<h2 id="概率算法">概率算法</h2>
<p>概率图灵机<span class="math inline">\(M\)</span>是某些步有两个合法的随机转移方向,并且有<span class="math inline">\(k\)</span>个随机转移的分支的概率为<span class="math inline">\(2^{-k}\)</span>.此时<span class="math inline">\(M\)</span>接受输入<span class="math inline">\(w\)</span>的概率为所有接受<span class="math inline">\(w\)</span>的分支的概率之和,拒绝<span class="math inline">\(w\)</span>的概率为<span class="math inline">\(1-Pr(M接受w)\)</span>.称<span class="math inline">\(M\)</span>以错误概率<span class="math inline">\(\epsilon\)</span>判定<span class="math inline">\(A\)</span>,如果对任何<span class="math inline">\(w\in A\)</span>,有<span class="math inline">\(Pr(M接受w)\ge 1-\epsilon\)</span>,且对任何<span class="math inline">\(w\notin A\)</span>,有<span class="math inline">\(Pr(M拒绝w)\ge 1-\epsilon\)</span>.</p>
<p>BPP是所有能被概率图灵机以多项式时间和<span class="math inline">\(\frac{1}{3}\)</span>的错误概率判定的语言.我们有放大引理:设<span class="math inline">\(0\le\epsilon&lt;\frac{1}{2}\)</span>,<span class="math inline">\(p(n)\)</span>是多项式,则任一多项式时间的错误概率为<span class="math inline">\(\epsilon\)</span>的概率图灵机等价于某个多项式时间的错误概率为<span class="math inline">\(2^{-p(n)}\)</span>的概率图灵机.</p>
<p>判定一个数是否为素数,我们有Fermat检验法:随机挑选若干正整数<span class="math inline">\(a_1,\cdots,a_k\)</span>,判断是否<span class="math inline">\(a_i^{p-1}\equiv 1(\mod p)\)</span>.在此基础上进行二次探测,就得到Miller-Rabin素数判定算法;它检验一个奇合数时,错误的概率小于等于<span class="math inline">\(2^{-k}\)</span>,进而属于BPP.</p>
<p>一个分支程序是一个有向无环图,其顶点除了两个输出顶点标号为0和1,其他用变量标号,并且总是有0和1两条出去的边.一个只读一次的分支程序是指从起点到输出顶点的所有可能路径上,标号不会重复的分支程序.判定两个只读一次的分支程序是否等价的问题<span class="math inline">\(EQ_{ROBP}\in BPP\)</span>.</p>
<h2 id="交替式图灵机">交替式图灵机</h2>
<h2 id="交互式证明系统">交互式证明系统</h2>
<h2 id="并行计算">并行计算</h2>
<h2 id="密码学">密码学</h2>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/01/24/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/" rel="prev" title="组合数学笔记">
      <i class="fa fa-chevron-left"></i> 组合数学笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/06/%E9%87%8D%E5%90%AF/" rel="next" title="重启">
      重启 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC0%E7%AB%A0"><span class="nav-number">1.</span> <span class="nav-text">第0章</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC1%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%AF%AD%E8%A8%80"><span class="nav-number">2.</span> <span class="nav-text">第1章 正则语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">2.1.</span> <span class="nav-text">有限自动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">非确定性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E6%AD%A3%E5%88%99%E8%AF%AD%E8%A8%80"><span class="nav-number">2.4.</span> <span class="nav-text">非正则语言</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC2%E7%AB%A0-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E8%AF%AD%E8%A8%80"><span class="nav-number">3.</span> <span class="nav-text">第2章 上下文无关语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">上下文无关文法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">3.2.</span> <span class="nav-text">下推自动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E8%AF%AD%E8%A8%80"><span class="nav-number">3.3.</span> <span class="nav-text">非上下文无关语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E6%80%A7%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E8%AF%AD%E8%A8%80"><span class="nav-number">3.4.</span> <span class="nav-text">确定性上下文无关语言</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC3%E7%AB%A0-church-turing%E8%AE%BA%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">第3章 Church-Turing论题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%81%B5%E6%9C%BA"><span class="nav-number">4.1.</span> <span class="nav-text">图灵机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="nav-number">4.2.</span> <span class="nav-text">图灵机的变种</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.3.</span> <span class="nav-text">算法的定义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">第4章 可判定性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%88%A4%E5%AE%9A%E8%AF%AD%E8%A8%80"><span class="nav-number">5.1.</span> <span class="nav-text">可判定语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">不可判定性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%8F%AF%E5%BD%92%E7%BA%A6%E6%80%A7"><span class="nav-number">6.</span> <span class="nav-text">第5章 可归约性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E9%97%AE%E9%A2%98"><span class="nav-number">6.1.</span> <span class="nav-text">语言中的不可判定问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E9%97%AE%E9%A2%98"><span class="nav-number">6.1.1.</span> <span class="nav-text">几个不可判定问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%8E%86%E5%8F%B2%E6%96%B9%E6%B3%95"><span class="nav-number">6.1.2.</span> <span class="nav-text">计算历史方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.</span> <span class="nav-text">一个简单的不可判定问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E4%B8%8D%E5%8F%AF%E8%A7%84%E7%BA%A6%E6%80%A7"><span class="nav-number">6.3.</span> <span class="nav-text">映射不可规约性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%8F%AF%E8%AE%A1%E7%AE%97%E6%80%A7%E9%AB%98%E7%BA%A7%E4%B8%93%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">第6章 可计算性高级专题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9A%E7%90%86"><span class="nav-number">7.1.</span> <span class="nav-text">递归定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%90%86%E8%AE%BA%E7%9A%84%E5%8F%AF%E5%BD%92%E7%BA%A6%E6%80%A7"><span class="nav-number">7.2.</span> <span class="nav-text">逻辑理论的可归约性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%81%B5%E5%8F%AF%E5%BD%92%E7%BA%A6%E6%80%A7"><span class="nav-number">7.3.</span> <span class="nav-text">图灵可归约性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">7.4.</span> <span class="nav-text">信息的定义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">8.</span> <span class="nav-text">第7章 时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E9%87%8F%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">8.1.</span> <span class="nav-text">测量复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#p%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.</span> <span class="nav-text">P类问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#np%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="nav-number">8.3.</span> <span class="nav-text">NP类问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#np%E5%AE%8C%E5%85%A8"><span class="nav-number">8.4.</span> <span class="nav-text">NP完全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%97%B6%E9%97%B4%E8%A7%84%E7%BA%A6np%E5%AE%8C%E5%85%A8"><span class="nav-number">8.4.1.</span> <span class="nav-text">多项式时间规约,NP完全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cook-levin%E5%AE%9A%E7%90%86"><span class="nav-number">8.4.2.</span> <span class="nav-text">Cook-Levin定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84np%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">8.4.3.</span> <span class="nav-text">其他的NP完全问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">9.</span> <span class="nav-text">第8章 空间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#savitch%E5%AE%9A%E7%90%86"><span class="nav-number">9.1.</span> <span class="nav-text">Savitch定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pspace%E7%B1%BB"><span class="nav-number">9.2.</span> <span class="nav-text">PSPACE类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pspace%E5%AE%8C%E5%A4%87"><span class="nav-number">9.3.</span> <span class="nav-text">PSPACE完备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#l%E5%92%8Cnl%E7%B1%BB"><span class="nav-number">9.4.</span> <span class="nav-text">L和NL类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nl%E5%AE%8C%E5%A4%87"><span class="nav-number">9.5.</span> <span class="nav-text">NL完备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nlconl"><span class="nav-number">9.6.</span> <span class="nav-text">NL&#x3D;coNL</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC9%E7%AB%A0-%E9%9A%BE%E8%A7%A3%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">第9章 难解性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E5%AE%9A%E7%90%86"><span class="nav-number">10.1.</span> <span class="nav-text">层次定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%AF%B9%E5%8C%96"><span class="nav-number">10.2.</span> <span class="nav-text">相对化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B5%E8%B7%AF%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="nav-number">10.3.</span> <span class="nav-text">电路复杂性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC10%E7%AB%A0-%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E9%AB%98%E7%BA%A7%E4%B8%93%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text">第10章 计算复杂度理论高级专题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95"><span class="nav-number">11.1.</span> <span class="nav-text">近似算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E7%8E%87%E7%AE%97%E6%B3%95"><span class="nav-number">11.2.</span> <span class="nav-text">概率算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%9B%BF%E5%BC%8F%E5%9B%BE%E7%81%B5%E6%9C%BA"><span class="nav-number">11.3.</span> <span class="nav-text">交替式图灵机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%AF%81%E6%98%8E%E7%B3%BB%E7%BB%9F"><span class="nav-number">11.4.</span> <span class="nav-text">交互式证明系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="nav-number">11.5.</span> <span class="nav-text">并行计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E5%AD%A6"><span class="nav-number">11.6.</span> <span class="nav-text">密码学</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">PeriodicLaw</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PeriodicLaw</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
